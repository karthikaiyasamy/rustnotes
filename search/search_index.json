{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Hello world from Rust \ud83e\udd80","text":""},{"location":"#what-is-rust","title":"What is Rust?","text":"<p>Rust is a programming language that is known for its excellent performance. This means that Rust programs can execute quickly and efficiently, making it a great choice for building high-performance systems.</p> <p>One of the main reasons for Rust's performance is its static type system and ownership system, which allow the Rust compiler to perform many optimizations at compile time. For example, because Rust variables have a fixed type, the compiler can generate more efficient code by knowing exactly what type of data a variable will contain at runtime. Similarly, because Rust's ownership system ensures that data is never accessed after it goes out of scope, the compiler can automatically deallocate memory and eliminate the need for garbage collection.</p> <p>Another important feature of Rust is its emphasis on memory safety. Rust is designed to prevent common programming errors that can lead to security vulnerabilities and data corruption, such as null reference errors, data races, and buffer overflows. Rust achieves this through a combination of a borrowing and ownership system, a garbage collector, and a range of other safety features.</p> <p>We will start looking at each of those in detail in the subsequent sections. </p>"},{"location":"#rust-learning-resources","title":"Rust learning resources","text":"<p>Before we jump in, I like to list some of the resources I used to learn(ing) Rust \ud83e\udd80.  </p> <ul> <li>The best way to learn the language is from what we fondly call \"The Book\", here https://doc.rust-lang.org/book/</li> <li>Another fantastic book is \"Programming Rust: Fast, Safe Systems Development\", 2021 edition specifically.</li> <li>https://www.youtube.com/c/NoBoilerplate </li> </ul>"},{"location":"Fearless%20concurrency/","title":"Fearless concurrency","text":""},{"location":"Fearless%20concurrency/#fearless-concurrency","title":"Fearless concurrency","text":"<p>Rust is a programming language that is designed to enable fearless concurrency, which means that it is designed to make it easy for programmers to write concurrent code that is both safe and efficient.</p> <p>One of the main ways that Rust enables fearless concurrency is through the use of lightweight threads, called \"green threads,\" which are managed by the Rust runtime. Green threads are lightweight because they do not correspond directly to operating system threads, and they can be created and switched between quickly and efficiently. This makes it easy for Rust programs to create and manage many threads without incurring a performance penalty.</p> <p>Here's an example of how to create and use green threads in Rust:</p> <pre><code>use std::thread;\nuse std::time::Duration;\n\nfn main() {\n    let handle = thread::spawn(|| {\n        println!(\"I'm a new thread!\");\n        thread::sleep(Duration::from_secs(1));\n        println!(\"I'm still alive!\");\n    });\n    println!(\"I'm the main thread!\");\n    handle.join().unwrap();\n    println!(\"The new thread has finished.\");\n}\n</code></pre> <p>In this example, we use the <code>thread::spawn</code> function to create a new green thread and pass it a closure that contains the code that the thread should run. The <code>spawn</code> function returns a <code>JoinHandle</code> that can be used to wait for the thread to finish. We then print a message from the main thread and use the <code>join</code> method on the <code>JoinHandle</code> to wait for the new thread to finish.</p> <p>Another way that Rust enables fearless concurrency is through the use of shared-state concurrency, which allows multiple threads to access and modify shared data in a safe and controlled way. In Rust, shared-state concurrency is implemented using a system of locks and mutexes that ensure that only one thread can access shared data at a time.</p> <p>Here's an example of how to use shared-state concurrency in Rust:</p> <pre><code>use std::sync::{Arc, Mutex};\nuse std::thread;\n\nfn main() {\n    let data = Arc::new(Mutex::new(0));\n    let data_clone = data.clone();\n    let handle = thread::spawn(move || {\n        let mut data = data_clone.lock().unwrap();\n        *data += 1;\n    });\n    handle.join().unwrap();\n    let data = data.lock().unwrap();\n    println!(\"The value of data is {}\", *data);\n}\n</code></pre> <p>In this example, we use an <code>Arc</code> (atomic reference count) and a <code>Mutex</code> to create a shared, mutable value that can be accessed and modified by multiple threads. We use the <code>clone</code> method on the <code>Arc</code> to create a copy of the <code>Arc</code> that can be moved into the new thread, and we use the <code>lock</code> method on the <code>Mutex</code> to acquire a mutable reference to the shared data. We then modify the shared data and print its value from the main thread.</p> <p>Overall, Rust's support for fearless concurrency makes it a great choice for building concurrent and parallel systems. By providing lightweight threads and safe shared-state concurrency, Rust helps developers write concurrent code that is both efficient and safe.</p>"},{"location":"Fearless%20concurrency/#additional-reading","title":"Additional reading:","text":"<p>Threads, locks, and mutexes are important concepts in concurrent programming, which refers to the execution of multiple threads or processes simultaneously.</p> <p>Threads are independent execution paths within a single program. They can be used to perform tasks concurrently, allowing a program to perform multiple tasks at the same time. In Rust, threads are created using the <code>std::thread</code> module, and they are managed by the Rust runtime.</p> <p>Locks are a mechanism that can be used to protect shared resources from being accessed or modified concurrently by multiple threads. In Rust, locks are implemented using the <code>std::sync::Mutex</code> type, which provides mutual exclusion, meaning that only one thread can access the protected resource at a time.</p> <p>Here's an example of how to use a lock in Rust:</p> <pre><code>use std::sync::Mutex;\nuse std::thread;\n\nfn main() {\n    let data = Mutex::new(0);\n    let data_clone = data.clone();\n    let handle = thread::spawn(move || {\n        let mut data = data_clone.lock().unwrap();\n        *data += 1;\n    });\n    handle.join().unwrap();\n    let data = data.lock().unwrap();\n    println!(\"The value of data is {}\", *data);\n}\n</code></pre> <p>In this example, we create a new <code>Mutex</code> called <code>data</code> and initialize it with the value 0. We then create a new thread and pass it a closure that acquires a lock on the <code>Mutex</code> using the <code>lock</code> method and modifies the shared data. Finally, we join the thread and print the value of the <code>Mutex</code>.</p> <p>Mutexes are a type of lock that can be used to protect shared resources from being accessed or modified concurrently by multiple threads. In Rust, mutexes are implemented using the <code>std::sync::Mutex</code> type, which provides mutual exclusion, meaning that only one thread can access the protected resource at a time.</p> <p>Here's an example of how to use a mutex in Rust:</p> <pre><code>use std::sync::Mutex;\nuse std::thread;\n\nfn main() {\n    let data = Mutex::new(0);\n    let data_clone = data.clone();\n    let handle = thread::spawn(move || {\n        let mut data = data_clone.lock().unwrap();\n        *data += 1;\n    });\n    handle.join().unwrap();\n    let data = data.lock().unwrap();\n    println!(\"The value of data is {}\", *data);\n}\n</code></pre> <p>In this example, we create a new <code>Mutex</code> called <code>data</code> and initialize it with the value 0. We then create a new thread and pass it a closure that acquires a lock on the <code>Mutex</code> using the <code>lock</code> method and modifies the shared data. Finally, we join the thread and print the value of the <code>Mutex</code>.</p> <p>Overall, threads, locks, and mutexes are important tools for building concurrent and parallel systems in Rust. By providing a way to create and manage threads, and a mechanism for protecting shared resources from concurrent access, Rust enables developers to write efficient and safe concurrent code.</p>"},{"location":"No%20Billion%20dollar%20mistake/","title":"No Billion dollar mistake","text":"<p>No billion dollar mistake</p> <p>In Rust, the concept of \"null\" does not exist. This means that Rust does not have a null type or a null value that can be assigned to a variable.</p> <p>One of the main reasons for this design decision is to prevent null reference errors, which are a common source of bugs in other programming languages. In languages with a null type, it is possible for a variable to be null, which means that it does not refer to any object. If a programmer tries to access a method or field of a null object, it will result in a null reference error.</p> <p>To prevent null reference errors, Rust has a number of alternatives to the null type. One of these alternatives is the <code>Option</code> type, which represents a value that may or may not be present. The <code>Option</code> type is defined as follows:</p> <pre><code>enum Option&lt;T&gt; {\n    Some(T),\n    None,\n}\n</code></pre> <p>The <code>Option</code> type has two variants: Some, which contains a value of type <code>T</code>, and <code>None</code>, which represents the absence of a value. Here's an example of how to use the <code>Option</code> type in Rust:</p> <pre><code>fn main() {\n    let x = Some(5);  // x is a Some variant containing the value 5\n    let y = None;  // y is a None variant\n    match x {\n        Some(val) =&gt; println!(\"x is some and has value {}\", val),\n        None =&gt; println!(\"x is none\"),\n    }\n    match y {\n        Some(val) =&gt; println!(\"y is some and has value {}\", val),\n        None =&gt; println!(\"y is none\"),\n    }\n}\n</code></pre> <p>In this example, we create two variables, <code>x</code> and <code>y</code>, both of which have the type<code>Option&lt;i32&gt;</code>. <code>x</code> is a <code>Some</code> variant containing the value 5, while <code>y</code> is a <code>None</code> variant. We use a <code>match</code> expression to pattern match on the variant of each variable and print a message depending on the variant.</p> <p>Another alternative to the null type in Rust is the <code>Result</code> type, which represents a value that may be Ok or an error. The <code>Result</code> type is defined as follows:</p> <pre><code>enum Result&lt;T, E&gt; {\n    Ok(T),\n    Err(E),\n}\n</code></pre> <p>The <code>Result</code> type has two variants: <code>Ok</code>, which contains a value of type <code>T</code>, and <code>Err</code>, which contains a value of type <code>E</code>. Here's an example of how to use the <code>Result</code> type in Rust:</p> <pre><code>fn divide(x: i32, y: i32) -&gt; Result&lt;i32, &amp;'static str&gt; {\n    if y == 0 {\n        return Err(\"division by zero\");\n    }\n    Ok(x / y)\n}\n\n\nfn main() {\n    let x = 5;\n    let y = 2;\n    let result = divide(x, y);\n    match result {\n        Ok(val) =&gt; println!(\"result is ok and has value {}\", val),\n        Err(err) =&gt; println!(\"result is an error: {}\", err),\n    }\n}\n</code></pre> <p>In this example, we define a function <code>divide</code> that takes two integers and returns a <code>Result</code> with the result of the division. If the divisor is 0, the function returns an <code>Err</code> variant</p>"},{"location":"Performance/","title":"Performance","text":"<p>Performance</p> <p>Rust is a programming language that is known for its excellent performance. This means that Rust programs can execute quickly and efficiently, making it a great choice for building high-performance systems.</p> <p>One of the main reasons for Rust's performance is its static type system and ownership system, which allow the Rust compiler to perform many optimizations at compile time. For example, because Rust variables have a fixed type, the compiler can generate more efficient code by knowing exactly what type of data a variable will contain at runtime. Similarly, because Rust's ownership system ensures that data is never accessed after it goes out of scope, the compiler can automatically deallocate memory and eliminate the need for garbage collection.</p> <p>Here's an example of how Rust's static type system and ownership system can improve performance:</p> <pre><code>fn main() {\n    let x = 5;  // x is an i32\n    let y = x + 1;  // y is also an i32\n    let z = &amp;y;  // z is a reference to an i32\n    let a = *z + 1;  // a is an i32\n    println!(\"x = {}, y = {}, z = {}, a = {}\", x, y, z, a);\n}\n</code></pre> <p>In this example, we create four variables, <code>x</code>, <code>y</code>, <code>z</code>, and <code>a</code>, all of which are integers. Because the type of each variable is known at compile time, the Rust compiler can generate efficient code to perform the arithmetic operations and deallocate memory when each variable goes out of scope.</p> <p>Another reason for Rust's performance is its support for low-level programming, which allows developers to write code that has direct control over the hardware and can be optimized for specific platforms. Rust's support for low-level programming includes features such as inline assembly, no-std support, and safe zero-cost abstractions.</p> <p>Here's an example of how to use inline assembly in Rust:</p> <pre><code>fn main() {\n    let x = 5;\n    let y = 10;\n    let mut result = 0;\n    unsafe {\n        // inline assembly to add x and y and store the result in result\n        asm!(\"add {}, {}\", in(reg) x, in(reg) y, out(reg) result);\n    }\n    println!(\"The result is {}\", result);\n}\n</code></pre> <p>In this example, we use the <code>asm!</code> macro to insert inline assembly into our Rust code. The assembly code performs the addition of <code>x</code> and <code>y</code> and stores the result in <code>result</code>. This allows us to write low-level code that can be optimized for specific platforms and can take advantage of hardware-specific instructions.</p> <p>Overall, Rust's excellent performance makes it a great choice for building high-performance systems. Its static type system, ownership system, and support for low-level programming allow Rust programs to execute quickly and efficiently.</p>"},{"location":"Rust%20memory%20safety/","title":"Rust memory safety","text":"<p>Rust memory safety</p> <p></p> <p>Rust is a programming language that is known for its emphasis on memory safety. This means that Rust is designed to prevent common programming errors that can lead to security vulnerabilities and data corruption.</p> <p>One of the main ways that Rust ensures memory safety is through the use of a borrowing and ownership system. In Rust, every value has a single owner, and that owner has the sole responsibility for managing the value's lifetime. When a value is borrowed, the borrower is only allowed to read or use the value, not modify it or take ownership of it. This system helps prevent data races, which can occur when two or more threads try to access and modify the same data simultaneously.</p> <p>Here's an example of Rust's borrowing and ownership system in action:</p> <pre><code>fn main() {\n    let s = String::from(\"hello\");  // s is a new String with value \"hello\"\n    let t = &amp;s;  // t is a reference to s\n    println!(\"{}\", t);  // we can use t to read the value of s\n    // s.push_str(\", world!\");  // this would cause a compile-time error, because t is still borrowing s\n}\n</code></pre> <p>In this example, we create a new <code>String</code> with the value \"hello\", and then create a reference to it called <code>t</code>. We are able to use <code>t</code> to read the value of the <code>String</code>, but we are not allowed to modify it. If we tried to modify <code>s</code> while <code>t</code> was borrowing it, we would get a compile-time error.</p> <p>Another way that Rust ensures memory safety is through the use of a garbage collector. When an object is no longer needed, the garbage collector will automatically deallocate its memory to prevent memory leaks. This means that Rust programmers do not need to manually manage memory allocation and deallocation, which can be a common source of bugs in other languages.</p> <p>Here's an example of Rust's garbage collector in action:</p> <pre><code>fn main() {\n    let x = Box::new(5);  // x is a box containing the value 5\n    let y = x;  // y is now the owner of the value 5\n    // println!(\"{}\", x);  // this would cause a compile-time error, because x has been moved to y\n    println!(\"{}\", y);  // we can use y to access the value 5\n}\n</code></pre> <p>In this example, we create a new <code>Box</code> called <code>x</code> that contains the value 5. We then create a new variable <code>y</code> and assign <code>x</code> to it. This means that <code>y</code> is now the owner of the value 5, and <code>x</code> is no longer valid. If we tried to use x after it was moved to <code>y</code>, we would get a compile-time error.</p> <p>Overall, Rust's memory safety features make it a great choice for building secure and reliable software. By preventing common programming errors and automating memory management, Rust helps developers write code that is both efficient and safe.</p>"},{"location":"Type%20safety/","title":"Type safety","text":"<p>Type Safety</p> <p>Rust is a statically typed programming language, which means that the type of a variable must be known at compile time. This is in contrast to dynamically typed languages, where the type of a variable is determined at runtime.</p> <p>One of the unique features of Rust's type system is its strong type inference. This means that in many cases, the programmer does not have to explicitly specify the type of a variable. Instead, the compiler will infer the type based on the context in which the variable is used.</p> <p>For example, consider the following code:</p> <pre><code>let x = 5;\nlet y = \"hello\";\n</code></pre> <p>In this case, the compiler will infer that x is an integer and y is a string. This saves the programmer from having to explicitly specify the types, while still ensuring type safety.</p> <p>Another important aspect of Rust's type system is its support for generics. Generics allow for the creation of reusable code that can work with multiple types.</p> <p>For example, consider the following code:</p> <pre><code>fn max&lt;T: Ord&gt;(a: T, b: T) -&gt; T {\n    if a &gt; b {\n        a\n    } else {\n        b\n    }\n}\n</code></pre> <p>This function returns the maximum of two values, but the type of those values is not specified. Instead, the function is defined using a generic type parameter T, which must implement the Ord trait. This allows the function to work with any type that implements Ord, such as integers, floating point numbers, and strings.</p> <p>Overall, Rust's type system is designed to provide strong type safety and flexibility through features like type inference and generics. This allows programmers to write code that is both correct and efficient, while still being able to work with a wide range of types.</p>"}]}